# 硬件伪装技术求助文档

## 项目背景

我们正在开发一个基于Docker的Linux学习平台，运行在Codespace环境中。项目为每个用户创建独立的Ubuntu容器，提供Linux学习环境。

### 当前环境配置
- **宿主机**: GitHub Codespace (4核CPU, 15GB内存, 118GB临时存储)
- **容器技术**: Docker + Ubuntu 22.04
- **用户容器**: 每用户一个独立容器，512MB内存限制，512 CPU shares
- **安全策略**: 非特权容器，dropped capabilities，no-new-privileges

### 项目架构
```
Codespace Host (4C/15GB)
├── 主应用容器 (Node.js后端 + 前端)
├── 用户容器1 (Ubuntu, 512MB限制)
├── 用户容器2 (Ubuntu, 512MB限制)
└── ...
```

## 技术需求

需要在用户容器内实现硬件信息伪装，让容器内显示为高配置服务器：
- **目标CPU**: 24核心 (当前真实4核)
- **目标内存**: 64GB (当前真实15GB)
- **目标存储**: 1TB (当前真实118GB临时存储)

## 技术约束

### 1. 安全限制
- 不能给容器特权模式 (`--privileged`)
- 如果必须临时提权，需要在伪装完成后立即收回
- 不能破坏宿主机安全性
- 不能影响其他用户容器

### 2. 伪装要求
- 容器内用户难以发现伪装痕迹
- 常用系统信息命令必须显示伪装数据：
  - `lscpu` - CPU信息
  - `htop` / `top` - 进程和系统监控
  - `neofetch` - 系统信息展示
  - `free -h` - 内存信息
  - `df -h` - 磁盘信息
  - `/proc/cpuinfo` - CPU详细信息
  - `/proc/meminfo` - 内存详细信息
  - `/proc/stat` - 系统统计信息

### 3. 技术限制
- 不使用简单的命令覆盖 (alias, function override)
- 不使用PATH劫持
- 需要在系统底层实现伪装
- 伪装数据要保持一致性

## 已尝试的方案

### 方案1: 文件系统挂载覆盖
```bash
# 尝试挂载伪造的proc文件
mount --bind /fake/cpuinfo /proc/cpuinfo
```
**问题**: 需要特权模式，违反安全约束

### 方案2: LD_PRELOAD库劫持
```c
// 劫持系统调用
int open(const char *pathname, int flags) {
    if (strcmp(pathname, "/proc/cpuinfo") == 0) {
        return open("/fake/cpuinfo", flags);
    }
    return real_open(pathname, flags);
}
```
**问题**: 部分程序直接读取proc文件系统，绕过库调用

### 方案3: 容器启动时文件替换
```dockerfile
COPY fake-cpuinfo /proc/cpuinfo
```
**问题**: /proc是内核虚拟文件系统，无法在构建时替换

## 技术难点

### 1. /proc文件系统伪装
- `/proc/cpuinfo` - CPU核心数和型号信息
- `/proc/meminfo` - 内存总量和使用情况
- `/proc/stat` - CPU统计信息
- `/proc/version` - 内核版本信息

### 2. 系统调用层面伪装
- `sysinfo()` 系统调用返回的内存信息
- `sched_getaffinity()` 返回的CPU亲和性
- `get_nprocs()` 返回的处理器数量

### 3. 动态一致性
- htop等工具实时读取多个数据源
- 需要保证所有数据源的一致性
- CPU使用率、内存使用率需要合理计算

## 当前代码结构

### 容器创建配置
```javascript
// backend/services/containerManager.js
const container = await this.docker.createContainer({
  Image: 'linux-ubuntu:latest',
  HostConfig: {
    Memory: 512 * 1024 * 1024, // 真实限制512MB
    CpuShares: 512, // 真实CPU限制
    SecurityOpt: ['no-new-privileges:true'],
    CapDrop: ['ALL'],
    CapAdd: ['CHOWN', 'DAC_OVERRIDE', 'FOWNER', 'SETGID', 'SETUID']
  }
});
```

### 用户环境设置
```javascript
// 在容器中执行的命令
const commands = [
  `useradd -m -s /bin/bash ${username}`,
  `usermod -aG sudo ${username}`,
  // 需要在这里添加硬件伪装逻辑
];
```

## 期望的技术方案

### 理想实现效果
1. 用户登录容器后，所有系统信息显示为高配置
2. 开发者工具 (htop, neofetch等) 显示伪装信息
3. 编程语言获取的系统信息也是伪装数据
4. 伪装对用户透明，无明显痕迹

### 可接受的复杂度
- 可以使用内核模块 (如果有非特权方案)
- 可以使用用户空间文件系统 (FUSE)
- 可以修改容器镜像构建过程
- 可以使用namespace技术

### 不可接受的方案
- 需要宿主机root权限
- 破坏容器安全隔离
- 影响宿主机稳定性
- 容易被用户发现的简单伪装

## 技术环境详情

### 宿主机信息
```bash
# CPU信息
$ lscpu
Architecture: x86_64
CPU(s): 4
Model name: Intel(R) Xeon(R) Platinum 8370C CPU @ 2.80GHz

# 内存信息  
$ free -h
              total        used        free
Mem:           15Gi       1.5Gi       737Mi

# 存储信息
$ df -h /tmp
/dev/sdb1       118G   19G   94G  17% /tmp
```

### 容器运行时
- Docker Engine 24.0+
- 非特权容器模式
- 用户命名空间隔离
- 网络桥接模式

### 目标用户体验
用户在容器内执行 `neofetch` 应该看到：
```
OS: Ubuntu 22.04 LTS x86_64
Host: High-Performance Server
Kernel: 5.15.0-xxx-generic
CPU: Intel Xeon Platinum (24) @ 2.80GHz
Memory: 2048MiB / 65536MiB
```

## 求助问题

1. **如何在非特权容器中实现/proc文件系统伪装？**
2. **是否有用户空间方案可以劫持系统信息查询？**
3. **如何确保伪装数据的一致性和实时性？**
4. **有没有现成的开源项目解决类似问题？**
5. **是否可以通过修改glibc或其他系统库实现？**

## 补充信息

### 项目代码仓库
- GitHub: webwww123/linuxdo-bash
- 主要文件: backend/services/containerManager.js
- 容器镜像构建: Dockerfile, docker/Dockerfile.ubuntu

### 相关技术栈
- Node.js + Express (后端)
- React (前端)  
- Docker + Docker Compose
- Ubuntu 22.04 (容器基础镜像)
- GitHub Codespace (运行环境)

### 时间要求
希望在1-2周内找到可行的技术方案并实现原型。

### 联系方式
如有技术建议或解决方案，欢迎通过GitHub Issues或其他方式联系。
